# 三. 基础
我们通过创建`App1`来介绍SDK的基本组件，`App1`是一个简单的银行程序，用户拥有一个账户和账户地址，用户之间可以相互发送coin。这个银行目前没有身份验证功能，且只能使用JSON进行序列化。

完整的代码可以在[app1.go](https://github.com/cosmos/cosmos-sdk/blob/v0.24.1/docs/sdk/core/examples/app1.go)看到。

## 1. Message
Message（消息）是应用状态机的基本输入。它们定义了交易的内容，可以包含任意信息。开发者通过实现`Msg`接口来创建消息类型：
```
// https://github.com/cosmos/cosmos-sdk/blob/v0.24.1/types/tx_msg.go

type Msg interface {
    // Return the message type.
    // Must be alphanumeric or empty.
    // Must correspond to name of message handler (XXX).
    Type() string

    // ValidateBasic does a simple validation check that
    // doesn't require access to any other information.
    ValidateBasic() error

    // Get the canonical byte representation of the Msg.
    // This is what is signed.
    GetSignBytes() []byte

    // Signers returns the addrs of signers that must sign.
    // CONTRACT: All signatures must be present to be valid.
    // CONTRACT: Returns addrs in some deterministic order.
    GetSigners() []AccAddress
}
```

`Msg`接口允许消息类型去定义基本的消息合法性校验，哪些内容需要被签名，以及谁需要对这些内容签名。

例如app1.go中，简易的token发送的消息类型：
```
// https://github.com/cosmos/cosmos-sdk/blob/v0.24.1/docs/sdk/core/examples/app1.go

// MsgSend to send coins from Input to Output
type MsgSend struct {
	From   sdk.AccAddress `json:"from"`
	To     sdk.AccAddress `json:"to"`
	Amount sdk.Coins   `json:"amount"`
}

// Implements Msg.
func (msg MsgSend) Type() string { return "bank" }
```

指定了消息应该转化成JSON格式，以及由发送者签名:
```
// Implements Msg. JSON encode the message.
func (msg MsgSend) GetSignBytes() []byte {
	bz, err := json.Marshal(msg)
	if err != nil {
		panic(err)
	}
	return bz
}

// Implements Msg. Return the signer.
func (msg MsgSend) GetSigners() []sdk.AccAddress {
	return []sdk.AccAddress{msg.From}
}
```

注意在以字符串的形式显示时或者以JSON形式表达时，SDK中的地址是任意Bech32编码格式的字符数组。通常，地址是公钥的哈希，所以在一笔交易需要签名时，我们可以使用它们作为独一无二的身份识别。

基本的有效性验证确保指定了发送方地址和接收方地址且发送数量是有效的：
```
// https://github.com/cosmos/cosmos-sdk/blob/v0.24.1/docs/sdk/core/examples/app1.go

// Implements Msg. Ensure the addresses are good and the
// amount is positive.
func (msg MsgSend) ValidateBasic() sdk.Error {
	if len(msg.From) == 0 {
		return sdk.ErrInvalidAddress("From address is empty")
	}
	if len(msg.To) == 0 {
		return sdk.ErrInvalidAddress("To address is empty")
	}
	if !msg.Amount.IsPositive() {
		return sdk.ErrInvalidCoins("Amount is not positive")
	}
	return nil
}
```

注意`ValidateBasic`方法会被SDK自动调用！

## 2. KVStore
KVStore是一个SDK应用程序基本的持久化存储层:
```
// https://github.com/cosmos/cosmos-sdk/blob/v0.24.1/types/store.go

type KVStore interface {
    Store

    // Get returns nil iff key doesn't exist. Panics on nil key.
    Get(key []byte) []byte

    // Has checks if a key exists. Panics on nil key.
    Has(key []byte) bool

    // Set sets the key. Panics on nil key.
    Set(key, value []byte)

    // Delete deletes the key. Panics on nil key.
    Delete(key []byte)

    // Iterator over a domain of keys in ascending order. End is exclusive.
    // Start must be less than end, or the Iterator is invalid.
    // CONTRACT: No writes may happen within a domain while an iterator exists over it.
    Iterator(start, end []byte) Iterator

    // Iterator over a domain of keys in descending order. End is exclusive.
    // Start must be greater than end, or the Iterator is invalid.
    // CONTRACT: No writes may happen within a domain while an iterator exists over it.
    ReverseIterator(start, end []byte) Iterator

 }
```

注意键值为nil时将会引发严重的错误！！！

IVAL存储是目前KVStore基础的实现。今后，我们计划去支持其它的默克尔结构的KVstore，就像Ethereum的基数树那样。

如我们所见，应用程序有许多不同的KVStore，每个都有一个不同的名称和不同的用途。对一个存储的访问权限由*对象能力关键字*来协调，其在应用程序启动期间必须被授权到一个处理器中。

## 3. Handler
现在我们有了一个消息类型和一个存储接口，我们可以使用一个Handler(处理器)来定义我们的状态变更函数：
```
// https://github.com/cosmos/cosmos-sdk/blob/v0.24.1/types/handler.go

// Handler defines the core of the state transition function of an application.
type Handler func(ctx Context, msg Msg) Result
```

经过这条消息(Msg)，处理器获得了环境信息(一个`Context`)，并返回一个`Result`。所有处理消息的必要信息都要能在上下文(Context)中获得。

哪里能获取所有的KVStore呢？在一条消息处理器中，对KVStore的访问权限通过对象能力关键字来被上下文限制。在处理消息期间，只有那些被明确赋予访问权限的处理器才能访问存储。

### 3.1 Context
SDK使用一个`Context`在函数之间传递通用的信息。最重要的是，`Context`限制了对KVStores的基于对象能力关键字的访问。只有那些被明确赋予访问权限的处理器才能够去访问相应的存储。

例如，FooHandler只能载入由其关键字赋予的存储：
```
// newFooHandler returns a Handler that can access a single store.
func newFooHandler(key sdk.StoreKey) sdk.Handler {
    return func(ctx sdk.Context, msg sdk.Msg) sdk.Result {
        store := ctx.KVStore(key)
        // ...
    }
}
```

`Context`类型仿照了Golang的[context.Context](https://golang.org/pkg/context/)，在网络中间件和路由应用中作为一个通过处理器函数简单传播请求内容的工具，context.Context已经变得极其普遍了。许多SDK对象的方法接受一个context作为第一个参数。

Context中同样包含了[区块头信息](https://github.com/tendermint/tendermint/blob/master/docs/spec/blockchain/blockchain.md#header)，包含了从区块链中得到的最新时间戳和有关最新区块的其他信息。

查看[Context API文档](https://godoc.org/github.com/cosmos/cosmos-sdk/types#Context)获取更多细节。

### 3.2 Result
Handler获取一个Context和Msg并返回一个Result。Result由相应的[ABCI result](https://github.com/tendermint/tendermint/blob/master/abci/types/types.proto#L165)驱动。它包含了返回值，错误信息，日志和交易的元数据：
```
// https://github.com/cosmos/cosmos-sdk/blob/v0.24.1/types/result.go

// Result is the union of ResponseDeliverTx and ResponseCheckTx.
type Result struct {

	// Code is the response code, is stored back on the chain.
	Code ABCICodeType

	// Data is any data returned from the app.
	Data []byte

	// Log is just debug information. NOTE: nondeterministic.
	Log string

	// GasWanted is the maximum units of work we allow this tx to perform.
	GasWanted int64

	// GasUsed is the amount of gas actually consumed. NOTE: unimplemented
	GasUsed int64

	// Tx fee amount and denom.
	FeeAmount int64
	FeeDenom  string

	// Tags are used for transaction indexing and pubsub.
	Tags Tags
}
```

我们将在之后的教程中讨论这些字段的更多细节。注意`Code`值为`0`的话认为是成功，其他值被认作失败。`Tags`可以包含关于交易的元数据，让我们能轻易地查找那些属于特定账户或行为的交易。

### 3.3 Handler
在App1中定义我们的处理器:
```
// https://github.com/cosmos/cosmos-sdk/blob/v0.24.1/docs/sdk/core/examples/app1.go

// Handle MsgSend.
// NOTE: msg.From, msg.To, and msg.Amount were already validated
// in ValidateBasic().
func handleMsgSend(key *sdk.KVStoreKey) sdk.Handler {
	return func(ctx sdk.Context, msg sdk.Msg) sdk.Result {
		sendMsg, ok := msg.(MsgSend)
		if !ok {
			// Create custom error message and return result
			// Note: Using unreserved error codespace
			return sdk.NewError(2, 1, "MsgSend is malformed").Result()
		}

		// Load the store.
		store := ctx.KVStore(key)

		// Debit from the sender.
		if res := handleFrom(store, sendMsg.From, sendMsg.Amount); !res.IsOK() {
			return res
		}

		// Credit the receiver.
		if res := handleTo(store, sendMsg.To, sendMsg.Amount); !res.IsOK() {
			return res
		}

		// Return a success (Code 0).
		// Add list of key-value pair descriptors ("tags").
		return sdk.Result{
			Tags: sendMsg.Tags(),
		}
	}
}
```

我们仅有一个单独的消息类型，所以只用定义`handleMsgSend`这个函数。

注意这个处理器对由关键词`keyAcc`指定的存储，有着不受限制的访问权限，所以必须要定义存储哪些内容及如何去做编码。之后，我们将引入高级的抽象使处理器来限制其只能去做我们能够做的操作。第一个例子，我们使用一个JSON格式的简易账户：
```
// https://github.com/cosmos/cosmos-sdk/blob/v0.24.1/docs/sdk/core/examples/app1.go

// Simple account struct
type appAccount struct {
	Coins sdk.Coins `json:"coins"`
}
```

Coins是SDK为多资产账户提供的类型。这里对于一个独立的的coin类型，我们可以只使用一个整数，但最好还是去了解下[Coins](https://godoc.org/github.com/cosmos/cosmos-sdk/types#Coins)

现在我们准备好了去处理MsgSend的两个部分：
```
// https://github.com/cosmos/cosmos-sdk/blob/v0.24.1/docs/sdk/core/examples/app1.go

// Convenience Handlers
func handleFrom(store sdk.KVStore, from sdk.AccAddress, amt sdk.Coins) sdk.Result {
	// Get sender account from the store.
	accBytes := store.Get(from)
	if accBytes == nil {
		// Account was not added to store. Return the result of the error.
		return sdk.NewError(2, 101, "Account not added to store").Result()
	}

	// Unmarshal the JSON account bytes.
	var acc appAccount
	err := json.Unmarshal(accBytes, &acc)
	if err != nil {
		// InternalError
		return sdk.ErrInternal("Error when deserializing account").Result()
	}

	// Deduct msg amount from sender account.
	senderCoins := acc.Coins.Minus(amt)

	// If any coin has negative amount, return insufficient coins error.
	if !senderCoins.IsNotNegative() {
		return sdk.ErrInsufficientCoins("Insufficient coins in account").Result()
	}

	// Set acc coins to new amount.
	acc.Coins = senderCoins

	// Encode sender account.
	accBytes, err = json.Marshal(acc)
	if err != nil {
		return sdk.ErrInternal("Account encoding error").Result()
	}

	// Update store with updated sender account
	store.Set(from, accBytes)
	return sdk.Result{}
}

func handleTo(store sdk.KVStore, to sdk.AccAddress, amt sdk.Coins) sdk.Result {
	// Add msg amount to receiver account
	accBytes := store.Get(to)
	var acc appAccount
	if accBytes == nil {
		// Receiver account does not already exist, create a new one.
		acc = appAccount{}
	} else {
		// Receiver account already exists. Retrieve and decode it.
		err := json.Unmarshal(accBytes, &acc)
		if err != nil {
			return sdk.ErrInternal("Account decoding error").Result()
		}
	}

	// Add amount to receiver's old coins
	receiverCoins := acc.Coins.Plus(amt)

	// Update receiver account
	acc.Coins = receiverCoins

	// Encode receiver account
	accBytes, err := json.Marshal(acc)
	if err != nil {
		return sdk.ErrInternal("Account encoding error").Result()
	}

	// Update store with updated receiver account
	store.Set(to, accBytes)
	return sdk.Result{}
}
```

处理器继续进行。我们先使用用于授权的能力关键字从上下文中加载KVStore。然后我们生成两个状态变化：一个针对发送者，一个针对接收者。每一个都把存储中的账户字符中由JSON格式解码，然后改变`Coins`, 再以JSON格式编码后放回到存储中。


## 4. Tx
在把这些都整合之前，最后一步就是`Tx`。虽然`Msg`包含应用程序中特定功能的内容，用户提供的输入实际上是一个序列化的`Tx`。应用程序可以有许多对`Msg`接口的实现，但是他们只能有一个`Tx`的单独实现：
```
// https://github.com/cosmos/cosmos-sdk/blob/v0.24.1/types/tx_msg.go

// Transactions objects must fulfill the Tx
type Tx interface {

	// Gets the Msg.
	GetMsgs() []Msg
}
```

`Tx`仅包含了一个`[]Msg`，可以包含额外的身份验证数据，比如签名和账户的nonce。应用程序必须指定它们的`Tx`要如何解码，因为往应用程序里输入是首要的事情。在引入`StdTx`的时候，我们再讨论`Tx`。

在第一个应用程序中，我们完全没有做任何的身份验证。这在访问权被严格控制的私有网络中可能是行得通的，就像client-side TLS certificates。但通常情况下，我们把身份验证权限加到我们的状态机中。我们会在下一个应用中使用`Tx`来实现。现在，`Tx`只嵌入了`MsgSend`和使用JSON：
```
// https://github.com/cosmos/cosmos-sdk/blob/v0.24.1/docs/sdk/core/examples/app1.go

//------------------------------------------------------------------
// Tx

// Simple tx to wrap the Msg.
type app1Tx struct {
	MsgSend
}

// This tx only has one Msg.
func (tx app1Tx) GetMsgs() []sdk.Msg {
	return []sdk.Msg{tx.MsgSend}
}

// JSON decode MsgSend.
func tx1Decoder(txBytes []byte) (sdk.Tx, sdk.Error) {
	var tx app1Tx
	err := json.Unmarshal(txBytes, &tx)
	if err != nil {
		return nil, sdk.ErrTxDecode(err.Error())
	}
	return tx, nil
}
```

## 5. BaseApp
最后，我们使用`BaseApp`来把这些整合到一块儿。

BaseApp是一个基于Tendermint ABCI的抽象，Tendermint ABCI通过在底层处理通用的用途来简化应用程序的开发。它作为SDK应用中两个关键组件存储和消息处理器之间的中介。BaseApp实现了`abci.Application`接口。查看[BaseApp API文档](https://godoc.org/github.com/cosmos/cosmos-sdk/baseapp)获取更多细节。

这里是App1的完整设置：
```
// https://github.com/cosmos/cosmos-sdk/blob/v0.24.1/docs/sdk/core/examples/app1.go

const (
	app1Name = "App1"
)

func NewApp1(logger log.Logger, db dbm.DB) *bapp.BaseApp {

	// Create the base application object.
	app := bapp.NewBaseApp(app1Name, logger, db, tx1Decoder)

	// Create a key for accessing the account store.
	keyAccount := sdk.NewKVStoreKey("acc")

	// Register message routes.
	// Note the handler gets access to the account store.
	app.Router().
		AddRoute("send", handleMsgSend(keyAccount))

	// Mount stores and load the latest state.
	app.MountStoresIAVL(keyAccount)
	err := app.LoadLatestVersion(keyAccount)
	if err != nil {
		cmn.Exit(err.Error())
	}
	return app
}
```

每个应用都有一个定义应用设置的方法。它一般包含在一个`app.go`文件里。在之后的教程中，我们将会讨论如何把应用程序同CLI，REST API，日志，和文件系统相连接。此时，注意这里我们为消息类型注册了控制器，授权它们去访问存储。

这里，我们仅有一个单独的Msg类型，`bank`，一个针对账户单独的存储，和一个单独的处理器。处理器被授予了对相应存储的访问权限。在之后的应用中，我们将有多个存储和处理器，可不是所有的处理器都能访问每一个存储。

在设置好交易解码器和消息处理的路由后，最后一步是去挂载这些存储并载入最新的版本。因为我们只有一个存储，我们就只挂载一个。

## 6. 执行
现在我们已经完成了应用的核心逻辑！从这里开始，我们可以用Go编写测试模块来初始化账户的存储，还有通过调用`app.DeliverTx`方法来执行交易了。

在一个实际的设置里，应用会以一个Tendermint共识引擎之上的ABCI应用程序的形式来运行。这将由一个Genesis文件来初始化，由底层的Tendermint共识提交的交易区块来驱动。一会儿我们将会讨论有关ABCI和它们是如何工作的更多细节，也可以查看[相关说明](https://github.com/tendermint/tendermint/blob/master/docs/abci-spec.md)。我们还可以看到怎样把我们的应用连接到一套完整的组件上去运行以及如何使用一个线上的区块链应用。

现在，我们注意下面，当接收到一笔交易时（通过`app.DeliverTx`），事件发生的顺序:

+ 序列化的交易由`app.DeliverTx`接收
+ 交易通过`TxDecoder`被反序列化
+ 对于交易中的每一个消息，运行`msg.ValidateBasic()`
+ 对于交易中的每一个消息，载入合适的处理器并对消息执行


## 7. 总结
现在我们已经有了一个简单应用的完整实现！

在接下来的章节，我们将会添加另一个Msg类型和另一个存储。一旦有多个消息类型后，因为需要解码成`Msg`接口，我们需要用一个更好的方式去解码交易。这也是为何我们要引入Amino——能用做解码接口类型的高级编码协议。